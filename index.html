<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, orientation=landscape">
    <title>Kid's Adventure - Touch Zone Edition</title>
    <!-- Import font chu viet tay Patrick Hand -->
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #f0f0f0;
            font-family: 'Patrick Hand', cursive;
            overflow: hidden;
            touch-action: none; /* Ngan chan cac thao tac zoom/pan mac dinh */
        }

        #game-container {
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border: 5px solid #555;
            background-color: #e0f7fa; 
            background-image: 
                linear-gradient(rgba(100, 149, 237, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(100, 149, 237, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            width: 800px;
            height: 400px;
            max-width: 100vw;
            max-height: 100vh;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
        }

        .screen {
            display: none;
            text-align: center;
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #ff4d4d;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
        }

        .screen.active {
            display: block;
        }

        h1 {
            color: #ff4d4d;
            font-size: 52px;
            margin: 0 0 10px 0;
            text-shadow: 1px 1px #333;
        }

        p {
            font-size: 24px;
            margin: 10px 0;
        }

        #score-display {
            position: absolute;
            top: 15px;
            left: 20px;
            font-size: 28px;
            font-weight: bold;
            color: #333;
            background: rgba(255,255,255,0.8);
            padding: 5px 15px;
            border-radius: 10px;
            border: 2px solid #ff4d4d;
            z-index: 5;
        }

        button {
            padding: 12px 40px;
            font-size: 28px;
            cursor: pointer;
            background-color: #ff4d4d;
            color: white;
            border: none;
            border-radius: 50px;
            transition: transform 0.2s, background-color 0.2s;
            font-family: 'Patrick Hand', cursive;
            font-weight: bold;
        }

        /* Vung cam cam ung an (Touch Zones) */
        #touch-zones {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            z-index: 20;
            pointer-events: auto;
        }

        .zone {
            /* De an vung cham, chung ta de transparent. 
               Co the bat background mau nhe de debug neu muon. */
            background: transparent; 
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #message-box {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 20px;
            font-weight: bold;
            display: none;
            pointer-events: none;
            z-index: 30;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="score-display">Distance: 0m</div>
        
        <div id="ui-overlay">
            <div id="start-screen" class="screen active">
                <h1>Kid's Journey</h1>
                <p>Enjoy the smooth and natural movement!</p>
                <button onclick="startGame()">Start Game</button>
                <p style="font-size: 16px;">Hold Left Screen to move. Tap Right Screen to Jump/Crouch.</p>
            </div>

            <div id="game-over-screen" class="screen">
                <h1 style="color: #333;">OOPS!</h1>
                <p id="final-score">You traveled: 0m</p>
                <button onclick="startGame()">Retry</button>
            </div>
        </div>

        <!-- He thong vung cham an -->
        <div id="touch-zones">
            <div class="zone" id="zone-tl"></div> <!-- Top Left: Move Right -->
            <div class="zone" id="zone-tr"></div> <!-- Top Right: Jump -->
            <div class="zone" id="zone-bl"></div> <!-- Bottom Left: Move Left -->
            <div class="zone" id="zone-br"></div> <!-- Bottom Right: Crouch -->
        </div>
        
        <div id="message-box"></div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const messageBox = document.getElementById('message-box');
        const scoreElement = document.getElementById('score-display');
        const finalScoreElement = document.getElementById('final-score');

        // Kich thuoc noi tai cua game
        canvas.width = 800;
        canvas.height = 400;

        let gameState = 'START';
        let player = {};
        let platforms = [];
        let enemies = [];
        let clouds = [];
        let vines = [];
        let ziplines = [];
        let particles = [];
        let keys = {};
        let score = 0;
        let cameraX = 0;
        let lastGeneratedX = 0;

        // --- KHOI TAO GAME ---
        function initGame() {
            score = 0; cameraX = 0; lastGeneratedX = 0;
            updateScoreUI();

            player = {
                x: 100, y: 200, width: 30, height: 45,
                velX: 0, velY: 0, speed: 5, jumpForce: 11,
                grounded: false, isDucking: false, canDoubleJump: true,
                isClimbing: false, isZipping: false,
                frameCount: 0, dir: -1 
            };

            platforms = [{ x: 0, y: 350, width: 800, height: 50, type: 'ground' }];
            enemies = []; particles = []; vines = []; ziplines = [];
            
            clouds = [];
            for(let i=0; i<6; i++) {
                clouds.push({ x: Math.random() * canvas.width, y: Math.random() * 150 + 20, speed: 0.2 + Math.random() * 0.3, size: 30 + Math.random() * 30 });
            }

            lastGeneratedX = 800;
            for(let i=0; i<8; i++) spawnNextChunk();
        }

        function startGame() {
            initGame();
            gameState = 'PLAYING';
            startScreen.classList.remove('active');
            gameOverScreen.classList.remove('active');
        }

        function updateScoreUI() {
            scoreElement.innerText = "Distance: " + Math.floor(score) + "m";
        }

        // --- XU LY DIEU KHIEN (KEYBOARD & TOUCH ZONES) ---
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        // Gan su kien cho cac vung cham an
        const setupTouchZone = (id, key) => {
            const zone = document.getElementById(id);
            zone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[key] = true;
            }, { passive: false });
            zone.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[key] = false;
            }, { passive: false });
            zone.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                keys[key] = false;
            }, { passive: false });
        };

        // Thiet lap theo yeu cau nguoi dung
        setupTouchZone('zone-tl', 'ArrowRight'); // Top Left -> Move Right (Tiáº¿n)
        setupTouchZone('zone-bl', 'ArrowLeft');  // Bottom Left -> Move Left
        setupTouchZone('zone-tr', 'ArrowUp');    // Top Right -> Jump
        setupTouchZone('zone-br', 'ArrowDown');  // Bottom Right -> Crouch/Duck

        function spawnNextChunk() {
            const rand = Math.random();
            let nextX = lastGeneratedX + 120 + Math.random() * 60;
            let nextY = 220 + Math.random() * 100;
            let width = 250 + Math.random() * 200;

            if (rand < 0.2) {
                const chainWidth = 350 + Math.random() * 150;
                platforms.push({ x: nextX, y: 300, width: 60, height: 30, type: 'platform' });
                platforms.push({ 
                    x: nextX + 60, y: 280, width: chainWidth, height: 20, 
                    type: 'chain_conveyor', bladeOffset: 0, 
                    bladeSpeed: 0.8 + Math.random() * 0.4 
                });
                platforms.push({ x: nextX + 60 + chainWidth, y: 300, width: 120, height: 30, type: 'platform' });
                lastGeneratedX = nextX + chainWidth + 180;
            } else if (rand < 0.4) {
                const chasmWidth = 550;
                platforms.push({ x: nextX, y: 300, width: 80, height: 30, type: 'platform' });
                vines.push({ x: nextX + 60, y: 80, height: 220 });
                ziplines.push({ x1: nextX + 60, y1: 100, x2: nextX + 60 + chasmWidth, y2: 240 });
                platforms.push({ x: nextX + chasmWidth + 10, y: 300, width: 150, height: 30, type: 'platform' });
                lastGeneratedX = nextX + chasmWidth + 160;
            } else {
                platforms.push({ x: nextX, y: nextY, width: width, height: 30, type: 'platform' });
                if (Math.random() < 0.3 && width > 150) {
                    platforms.push({ x: nextX + width/2 - 30, y: nextY - 40, width: 60, height: 40, type: 'arch' });
                }
                let eRand = Math.random();
                if (eRand < 0.2) { // Bird
                    enemies.push({ type: 'bird', x: nextX + width + 200, y: nextY - 80 - Math.random() * 60, width: 40, height: 30, speed: 1.5, dir: -1, hp: 1 });
                } else if (eRand < 0.45) { // Worm
                    enemies.push({ type: 'worm', x: nextX + 30, y: nextY - 20, width: 40, height: 20, speed: 0.8, dir: 1, startX: nextX, endX: nextX + width, hp: 1 });
                } else if (eRand < 0.7) { // Bug
                    enemies.push({ type: 'bug', x: nextX + 80, y: nextY - 40, width: 50, height: 40, speed: 1, dir: 1, startX: nextX, endX: nextX + width, hp: 2 });
                } else { // Spikes
                    enemies.push({ type: 'spikes', x: nextX + 110, y: nextY - 45, width: 40, height: 45 });
                }
                lastGeneratedX = nextX + width;
            }
        }

        // --- LOGIC UPDATE ---
        function update() {
            if (gameState !== 'PLAYING') return;

            clouds.forEach(c => { c.x -= c.speed; if (c.x + c.size * 2 < 0) { c.x = canvas.width + 50; c.y = Math.random() * 150 + 20; } });

            let currentDist = (player.x - 100) / 20;
            if (currentDist > score) score = currentDist;
            updateScoreUI();

            let onVine = null;
            for (let v of vines) {
                if (player.x + player.width > v.x - 15 && player.x < v.x + 15 &&
                    player.y + player.height > v.y && player.y < v.y + v.height) {
                    onVine = v; break;
                }
            }
            if (onVine && (keys['ArrowUp'] || keys['ArrowDown'])) {
                player.isClimbing = true; player.isZipping = false; player.velY = 0;
                player.x = onVine.x - player.width/2;
            } else if (!onVine) { player.isClimbing = false; }

            if (!player.isZipping) {
                for (let z of ziplines) {
                    let d = Math.abs((z.y2 - z.y1) * player.x - (z.x2 - z.x1) * player.y + z.x2 * z.y1 - z.y2 * z.x1) / 
                            Math.sqrt(Math.pow(z.y2 - z.y1, 2) + Math.pow(z.x2 - z.x1, 2));
                    if (d < 30 && player.x > z.x1 && player.x < z.x2 && player.velY > -3) {
                        player.isZipping = true; player.isClimbing = false; player.grounded = false; break;
                    }
                }
            }

            if (player.isClimbing) {
                if (keys['ArrowUp']) player.y -= 3;
                if (keys['ArrowDown']) player.y += 3;
                if (keys['Space'] || keys['ArrowLeft'] || keys['ArrowRight']) {
                    player.isClimbing = false; if (keys['Space']) player.velY = -player.jumpForce;
                }
            } else if (player.isZipping) {
                player.velY = 0; player.x += 3; 
                player.dir = 1; 
                let foundZ = false;
                for (let z of ziplines) {
                    if (player.x >= z.x1 && player.x <= z.x2) {
                        let t = (player.x - z.x1) / (z.x2 - z.x1);
                        player.y = z.y1 + t * (z.y2 - z.y1) + 20; 
                        foundZ = true; break;
                    }
                }
                if (!foundZ) { player.isZipping = false; player.velY = 2; }
                if (keys['Space'] || keys['ArrowDown']) player.isZipping = false;
            } else {
                if (keys['ArrowLeft']) { player.velX = -player.speed; player.dir = -1; }
                else if (keys['ArrowRight']) { player.velX = player.speed; player.dir = 1; }
                else player.velX = 0;

                if (keys['ArrowDown'] || keys['KeyS']) {
                    if (!player.isDucking) { player.isDucking = true; player.height = 25; player.y += 20; }
                } else {
                    if (player.isDucking) { player.isDucking = false; player.height = 45; player.y -= 20; }
                }

                if ((keys['ArrowUp'] || keys['KeyW'] || keys['Space']) && player.grounded) {
                    player.velY = -player.jumpForce; player.grounded = false; player.canDoubleJump = true;
                    keys['ArrowUp'] = keys['KeyW'] = keys['Space'] = false;
                } else if ((keys['ArrowUp'] || keys['KeyW'] || keys['Space']) && player.canDoubleJump) {
                    player.velY = -player.jumpForce * 0.8; player.canDoubleJump = false;
                    createParticles(player.x + player.width/2, player.y + player.height, '#fff', 5);
                    keys['ArrowUp'] = keys['KeyW'] = keys['Space'] = false;
                }
                player.velY += 0.5; player.x += player.velX; player.y += player.velY;
            }

            if (player.x < cameraX) player.x = cameraX;
            let targetCameraX = player.x - 250;
            if (targetCameraX > cameraX) cameraX = targetCameraX;

            if (!player.isClimbing && !player.isZipping) {
                player.grounded = false;
                for (let p of platforms) {
                    if (p.type === 'chain_conveyor') {
                        p.bladeOffset = (p.bladeOffset + p.bladeSpeed) % 200;
                        if (player.x < p.x + p.width && player.x + player.width > p.x &&
                            player.y + player.height >= p.y && player.y + player.height <= p.y + 20 && player.velY >= 0) {
                            player.y = p.y - player.height; player.velY = 0; player.grounded = true; player.canDoubleJump = true;
                            for (let i = -1; i < p.width / 100 + 1; i++) {
                                let bx = p.x + (i * 200) + p.bladeOffset;
                                if (bx > p.x && bx < p.x + p.width && Math.abs((player.x + player.width/2) - bx) < 25) endGame();
                            }
                        }
                    } else if (p.type === 'arch') {
                        if (player.x < p.x + p.width && player.x + player.width > p.x && player.y < p.y + p.height && player.y + player.height > p.y) {
                            if (!player.isDucking) {
                                if (player.velX > 0) player.x = p.x - player.width;
                                else if (player.velX < 0) player.x = p.x + p.width;
                            }
                        }
                    } else if (player.x < p.x + p.width && player.x + player.width > p.x && player.y < p.y + p.height && player.y + player.height > p.y) {
                        if (player.velY > 0 && player.y + player.height - player.velY <= p.y + 10) {
                            player.y = p.y - player.height; player.velY = 0; player.grounded = true; player.canDoubleJump = true;
                        }
                    }
                }
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];
                if (e.type !== 'spikes') {
                    if (e.type === 'worm') {
                        const wormCycle = (player.frameCount * 0.1) % (Math.PI * 2);
                        if (wormCycle < Math.PI) e.x += e.speed * e.dir * 1.5;
                    } else { e.x += (e.speed || 0) * (e.dir || 1); }
                    if (e.type === 'bird') { if (e.x < cameraX - 200 || e.x > cameraX + 1000) e.dir *= -1; }
                    else { if (e.x < e.startX || e.x + e.width > e.endX) e.dir *= -1; }
                }
                if (player.x < e.x + e.width && player.x + player.width > e.x && player.y < e.y + e.height && player.y + player.height > e.y) {
                    if (player.velY > 0 && e.type !== 'spikes' && e.type !== 'bird' && (player.y + player.height - player.velY) <= e.y + 15) {
                        if (e.type === 'bug' && e.hp > 1) { e.hp--; player.velY = -player.jumpForce * 0.7; createParticles(e.x + 20, e.y, 'white', 5); }
                        else { enemies.splice(i, 1); player.velY = -player.jumpForce * 0.7; }
                    } else endGame();
                }
            }

            if (player.x + canvas.width > lastGeneratedX) spawnNextChunk();
            if (player.y > canvas.height + 150) endGame();
            particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.alpha -= 0.02; if (p.alpha <= 0) particles.splice(i, 1); });
            player.frameCount++;
        }

        function endGame() { gameState = 'GAMEOVER'; gameOverScreen.classList.add('active'); finalScoreElement.innerText = "You traveled: " + Math.floor(score) + "m"; }
        function createParticles(x, y, color, count) { for (let i = 0; i < count; i++) { particles.push({ x, y, vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6, alpha: 1, color }); } }

        // --- DRAW FUNCTIONS ---

        function drawChainConveyor(ctx, p) {
            ctx.save();
            ctx.strokeStyle = '#555'; ctx.lineWidth = 6;
            ctx.beginPath(); ctx.moveTo(p.x, p.y + 10); ctx.lineTo(p.x + p.width, p.y + 10); ctx.stroke();
            ctx.fillStyle = '#777';
            for(let x = p.x; x < p.x + p.width; x += 15) { ctx.beginPath(); ctx.arc(x, p.y + 10, 4, 0, Math.PI * 2); ctx.fill(); }
            ctx.fillStyle = '#ff1744'; 
            for (let i = -1; i < p.width / 100 + 1; i++) {
                let bx = p.x + (i * 200) + p.bladeOffset;
                if (bx > p.x && bx < p.x + p.width) {
                    ctx.save(); ctx.translate(bx, p.y + 5); ctx.rotate(Date.now() / 100); 
                    ctx.beginPath();
                    for (let a = 0; a < 8; a++) {
                        let angle = (a / 8) * Math.PI * 2;
                        ctx.lineTo(Math.cos(angle) * 15, Math.sin(angle) * 15);
                        ctx.lineTo(Math.cos(angle + 0.2) * 8, Math.sin(angle + 0.2) * 8);
                    }
                    ctx.closePath(); ctx.fill();
                    ctx.strokeStyle = 'white'; ctx.lineWidth = 1; ctx.stroke();
                    ctx.restore();
                }
            }
            ctx.restore();
        }

        function drawEnemy(ctx, e, frameCount) {
            ctx.save();
            if (e.type === 'worm') {
                const wormCycle = (frameCount * 0.1) % (Math.PI * 2);
                const archHeight = Math.max(0, Math.sin(wormCycle) * 15);
                const bodyLength = 40 - (archHeight * 0.5);
                ctx.fillStyle = '#7cfc00'; ctx.strokeStyle = '#32cd32'; ctx.lineWidth = 2;
                for(let i=0; i<5; i++) {
                    let dotX = e.x + (i * bodyLength / 4);
                    let dotY = e.y + 15;
                    if (i > 0 && i < 4) dotY -= archHeight * (1 - Math.abs(2-i)*0.5);
                    ctx.beginPath(); ctx.arc(dotX, dotY, 6, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                    if ((e.dir > 0 && i === 4) || (e.dir < 0 && i === 0)) {
                        ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(dotX + 2*e.dir, dotY - 2, 2, 0, Math.PI * 2); ctx.fill();
                        ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(dotX + 3*e.dir, dotY - 2, 1, 0, Math.PI * 2); ctx.fill();
                    }
                }
            } else if (e.type === 'bug') {
                const mouthOpen = Math.abs(Math.sin(frameCount * 0.15)) * 0.7;
                ctx.fillStyle = '#9c27b0'; ctx.beginPath(); ctx.moveTo(e.x + 25, e.y + 20);
                let sA = (e.dir > 0) ? mouthOpen : Math.PI + mouthOpen;
                let eA = (e.dir > 0) ? Math.PI * 2 - mouthOpen : Math.PI - mouthOpen;
                ctx.arc(e.x + 25, e.y + 20, 20, sA, eA); ctx.closePath(); ctx.fill();
                ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(e.x + 25 + 5 * e.dir, e.y + 5, 7, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#6a1b9a'; ctx.beginPath(); ctx.arc(e.x + 25 + 7 * e.dir, e.y + 5, 3, 0, Math.PI * 2); ctx.fill();
                if (mouthOpen > 0.1) {
                    ctx.fillStyle = 'white';
                    for(let i=0; i<2; i++) {
                        let tA = (e.dir > 0) ? (i === 0 ? mouthOpen : -mouthOpen) : (i === 0 ? Math.PI - mouthOpen : Math.PI + mouthOpen);
                        let tx = e.x + 25 + Math.cos(tA) * 18; let ty = e.y + 20 + Math.sin(tA) * 18;
                        ctx.beginPath(); ctx.moveTo(tx, ty); ctx.lineTo(tx - 6 * e.dir, ty - 4); ctx.lineTo(tx - 6 * e.dir, ty + 4); ctx.fill();
                    }
                }
                if (e.hp > 1) { ctx.fillStyle = 'lime'; ctx.fillRect(e.x + 5, e.y - 15, 40, 4); }
            } else if (e.type === 'bird') {
                ctx.fillStyle = '#00bfff'; ctx.beginPath(); ctx.ellipse(e.x + 20, e.y + 15, 18, 12, 0, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#6a1b9a'; ctx.beginPath(); ctx.arc(e.dir > 0 ? e.x + 32 : e.x + 8, e.y + 12, 2, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#ff8c00'; ctx.beginPath(); let bX = e.dir > 0 ? e.x + 38 : e.x + 2; ctx.moveTo(bX, e.y + 12); ctx.lineTo(bX + 10 * e.dir, e.y + 15); ctx.lineTo(bX, e.y + 18); ctx.fill();
                ctx.fillStyle = '#1e90ff'; let wingAnim = Math.sin(frameCount * 0.1) * 20; ctx.beginPath(); ctx.moveTo(e.x + 20, e.y + 15); ctx.lineTo(e.x - 5, e.y + 15 - wingAnim); ctx.lineTo(e.x + 10, e.y + 25); ctx.fill();
            } else if (e.type === 'spikes') {
                ctx.fillStyle = '#2e7d32'; ctx.beginPath(); ctx.rect(e.x + 15, e.y + 5, 10, 40); ctx.fill();
                ctx.strokeStyle = '#2e7d32'; ctx.lineWidth = 6; ctx.lineCap = 'round';
                ctx.beginPath(); ctx.moveTo(e.x + 15, e.y + 25); ctx.lineTo(e.x + 5, e.y + 25); ctx.lineTo(e.x + 5, e.y + 15); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(e.x + 25, e.y + 15); ctx.lineTo(e.x + 35, e.y + 15); ctx.lineTo(e.x + 35, e.y + 5); ctx.stroke();
                ctx.fillStyle = '#1b5e20'; for(let k=0; k<5; k++) { ctx.fillRect(e.x + 18, e.y + 5 + k*8, 2, 2); }
            }
            ctx.restore();
        }

        function drawLeg(ctx, p, side, isZipping) {
            ctx.save();
            const bodyH = p.isDucking ? 15 : 25;
            const legRadius = 6;
            let lx = side * 7; 
            let ly = bodyH + 2;
            if (isZipping) {
                lx += Math.sin(p.frameCount * 0.1) * 8; 
                ly -= 2;
            } else if (!p.grounded || p.isClimbing) {
                ly += 2; 
                lx += side * 2;
            } else if (p.velX !== 0) {
                const animSpeed = 0.2;
                const offset = (side === 1) ? 0 : Math.PI;
                lx += Math.sin(p.frameCount * animSpeed + offset) * 8;
                ly += Math.abs(Math.cos(p.frameCount * animSpeed + offset)) * 4;
            }
            ctx.fillStyle = '#111'; ctx.beginPath(); ctx.arc(lx, ly, legRadius, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        }

        function drawPlayer(ctx, p) {
            ctx.save(); 
            ctx.translate(p.x + p.width/2, p.y + 12);
            ctx.scale(-p.dir, 1);
            if (p.isZipping) { ctx.rotate(Math.sin(p.frameCount * 0.1) * 0.2); }
            let breathe = Math.sin(p.frameCount * 0.1) * 1.5;
            if (p.velX !== 0 || !p.grounded || p.isClimbing || p.isZipping) breathe = 0;
            drawLeg(ctx, p, -1, p.isZipping); 
            drawLeg(ctx, p, 1, p.isZipping);  
            if (p.isZipping) {
                const handCycle = Math.sin(p.frameCount * 0.15);
                ctx.strokeStyle = '#3399ff'; ctx.lineWidth = 6; ctx.lineCap = 'round';
                let leftHandY = -25 + (handCycle > 0 ? handCycle * 10 : 0);
                ctx.beginPath(); ctx.moveTo(-5, 5); ctx.lineTo(-12, leftHandY); ctx.stroke();
                ctx.fillStyle = '#ffdbac'; ctx.beginPath(); ctx.arc(-12, leftHandY, 5, 0, Math.PI * 2); ctx.fill();
                let rightHandY = -25 + (handCycle < 0 ? -handCycle * 10 : 0);
                ctx.beginPath(); ctx.moveTo(5, 5); ctx.lineTo(12, rightHandY); ctx.stroke();
                ctx.fillStyle = '#ffdbac'; ctx.beginPath(); ctx.arc(12, rightHandY, 5, 0, Math.PI * 2); ctx.fill();
            } else {
                let armAngle = p.isClimbing ? Math.PI : 0;
                if (p.velX !== 0 && p.grounded) armAngle = Math.sin(p.frameCount * 0.2) * 0.5;
                ctx.save(); ctx.translate(0, 5); ctx.rotate(armAngle); ctx.fillStyle = '#3399ff'; ctx.fillRect(-15, 0, 6, 18); ctx.fillRect(9, 0, 6, 18); ctx.restore();
            }
            ctx.fillStyle = '#3399ff'; let bodyH = p.isDucking ? 15 : 25; ctx.fillRect(-10, 0 + breathe, 20, bodyH);
            ctx.translate(0, breathe); ctx.fillStyle = '#ffdbac'; ctx.beginPath(); ctx.arc(0, -2, 12, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#111'; ctx.beginPath(); ctx.arc(-4, -4, 2, 0, Math.PI * 2); ctx.arc(-8, -4, 2, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#ff4d4d'; ctx.beginPath(); ctx.arc(0, -7, 15, Math.PI, 0); ctx.fill(); ctx.fillRect(-15, -10, 30, 4);
            ctx.restore();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(700, 60, 25, 0, Math.PI * 2); ctx.fill();
            clouds.forEach(c => { ctx.fillStyle = 'white'; ctx.globalAlpha = 0.8; ctx.beginPath(); ctx.arc(c.x, c.y, c.size, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; });
            ctx.save(); ctx.translate(-cameraX, 0);
            vines.forEach(v => {
                ctx.save(); ctx.strokeStyle = '#228B22'; ctx.lineWidth = 4;
                ctx.beginPath(); ctx.moveTo(v.x, v.y); ctx.lineTo(v.x, v.y + v.height); ctx.stroke();
                ctx.fillStyle = '#32CD32';
                for(let i=0; i<v.height; i+=20) {
                    ctx.beginPath(); ctx.ellipse(v.x + 5, v.y + i, 8, 4, 0.5, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(v.x - 5, v.y + i + 10, 8, 4, -0.5, 0, Math.PI * 2); ctx.fill();
                }
                ctx.restore();
            });
            ziplines.forEach(z => {
                ctx.save(); ctx.strokeStyle = '#777'; ctx.lineWidth = 3; ctx.setLineDash([5, 5]);
                ctx.beginPath(); ctx.moveTo(z.x1, z.y1); ctx.lineTo(z.x2, z.y2); ctx.stroke();
                ctx.setLineDash([]); ctx.fillStyle = '#555';
                ctx.fillRect(z.x1 - 5, z.y1 - 10, 10, 20); ctx.fillRect(z.x2 - 5, z.y2 - 10, 10, 20);
                ctx.restore();
            });
            for (let p of platforms) {
                if (p.type === 'chain_conveyor') { drawChainConveyor(ctx, p); }
                else if (p.type === 'arch') { 
                    ctx.strokeStyle = 'orange'; ctx.lineWidth = 5; 
                    ctx.beginPath(); ctx.moveTo(p.x, p.y + p.height); ctx.lineTo(p.x, p.y); ctx.lineTo(p.x + p.width, p.y); ctx.lineTo(p.x + p.width, p.y + p.height); ctx.stroke();
                } 
                else { ctx.fillStyle = p.color || '#8d6e63'; ctx.fillRect(p.x, p.y, p.width, p.height); }
            }
            for (let e of enemies) drawEnemy(ctx, e, player.frameCount);
            particles.forEach(p => { ctx.globalAlpha = p.alpha; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI * 2); ctx.fill(); });
            ctx.globalAlpha = 1; drawPlayer(ctx, player);
            ctx.restore();
        }

        function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }
        window.onload = function() { initGame(); gameLoop(); };
        function showMessage(msg) { messageBox.innerText = msg; messageBox.style.display = 'block'; setTimeout(() => messageBox.style.display = 'none', 2000); }
    </script>
</body>
</html>
