<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, orientation=landscape">
    <title>Hanh Trinh Tuoi Tho - Brick Tunnel Master</title>
    <!-- Import font chu viet tay Patrick Hand -->
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #f0f0f0;
            font-family: 'Patrick Hand', cursive;
            overflow: hidden;
            touch-action: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border: 5px solid #555;
            background-color: #e0f7fa;
            background-image:
                linear-gradient(rgba(100, 149, 237, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(100, 149, 237, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            width: 800px;
            height: 400px;
            max-width: 100vw;
            max-height: 100vh;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #orientation-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #fff;
            z-index: 9999;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        @media (orientation: portrait) {
            #orientation-overlay { display: flex; }
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 100;
        }

        .screen {
            display: none;
            text-align: center;
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 40px;
            border-radius: 15px;
            border: 3px solid #ff4d4d;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            max-width: 85%;
        }

        .screen.active { display: block; }

        h1 {
            color: #ff4d4d;
            font-size: 42px;
            margin: 0 0 5px 0;
            text-shadow: 1px 1px #333;
        }

        .instructions {
            background: #fff9c4;
            padding: 10px;
            border-radius: 10px;
            border: 2px dashed #fbc02d;
            margin-bottom: 10px;
        }

        .instructions p {
            font-size: 16px;
            margin: 3px 0;
            color: #5d4037;
            text-align: left;
        }

        .copyright {
            margin-top: 10px;
            font-size: 13px;
            color: #777;
            border-top: 1px solid #eee;
            padding-top: 5px;
            line-height: 1.2;
        }

        #score-display {
            position: absolute;
            top: 15px;
            left: 20px;
            font-size: 28px;
            font-weight: bold;
            color: #333;
            background: rgba(255,255,255,0.8);
            padding: 5px 15px;
            border-radius: 10px;
            border: 2px solid #ff4d4d;
            z-index: 40;
        }

        button {
            padding: 10px 40px;
            font-size: 26px;
            cursor: pointer;
            background-color: #ff4d4d;
            color: white;
            border: none;
            border-radius: 50px;
            transition: transform 0.2s, background-color 0.2s;
            font-family: 'Patrick Hand', cursive;
            font-weight: bold;
        }

        #touch-zones {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            z-index: 20;
        }

        .zone {
            background: transparent;
            -webkit-tap-highlight-color: transparent;
        }

        #message-box {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(211, 47, 47, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 20px;
            font-weight: bold;
            display: none;
            pointer-events: none;
            z-index: 150;
        }
    </style>
</head>
<body>

    <div id="orientation-overlay">
        <div style="font-size: 50px;">üîÑ</div>
        <h2>Vui l√≤ng xoay ngang m√†n h√¨nh</h2>
        <p>ƒê·ªÉ c√≥ tr·∫£i nghi·ªám th√°m hi·ªÉm t·ªët nh·∫•t!</p>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="score-display">Distance: 0m</div>
        
        <div id="ui-overlay">
            <div id="start-screen" class="screen active">
                <h1>Kid's Journey</h1>
                
                <div class="instructions">
                    <p><strong>H∆∞·ªõng d·∫´n ch∆°i:</strong></p>
                    <p>‚Ä¢ G√≥c TR√äN TR√ÅI: Gi·ªØ ƒë·ªÉ ƒëi sang PH·∫¢I (Ti·∫øn)</p>
                    <p>‚Ä¢ G√≥c D∆Ø·ªöI TR√ÅI: Gi·ªØ ƒë·ªÉ ƒëi sang TR√ÅI (L√πi)</p>
                    <p>‚Ä¢ G√≥c TR√äN PH·∫¢I: Ch·∫°m ƒë·ªÉ NH·∫¢Y</p>
                    <p>‚Ä¢ G√≥c D∆Ø·ªöI PH·∫¢I: Ch·∫°m ƒë·ªÉ NG·ªíI (Ph·∫£i t·ª± chui khi qua h·∫ßm!)</p>
                    <p style="color: #d32f2f;">* ƒê·ª©ng ch·∫°m n√≥c h·∫ßm ho·∫∑c Kinh Kong l√† thua ngay!</p>
                </div>

                <button onclick="startGame()">B·∫Øt ƒë·∫ßu ch∆°i</button>

                <div class="copyright">
                    B·∫£n quy·ªÅn: Tr·∫ßn H·ªìng D√¢n<br>
                    Email: tranhongdan@tranphudlk.edu.vn
                </div>
            </div>

            <div id="game-over-screen" class="screen">
                <h1 style="color: #333;">OOPS!</h1>
                <p id="final-score" style="font-size: 24px;">Qu√£ng ƒë∆∞·ªùng: 0m</p>
                <button onclick="startGame()">Ch∆°i l·∫°i</button>
                <div class="copyright">
                    B·∫£n quy·ªÅn: Tr·∫ßn H·ªìng D√¢n<br>
                    tranhongdan@tranphudlk.edu.vn
                </div>
            </div>
        </div>

        <div id="touch-zones" style="display: none;">
            <div class="zone" data-key="ArrowRight" id="zone-tl"></div>
            <div class="zone" data-key="ArrowUp" id="zone-tr"></div>
            <div class="zone" data-key="ArrowLeft" id="zone-bl"></div>
            <div class="zone" data-key="ArrowDown" id="zone-br"></div>
        </div>
        
        <div id="message-box"></div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const messageBox = document.getElementById('message-box');
        const scoreElement = document.getElementById('score-display');
        const finalScoreElement = document.getElementById('final-score');
        const touchZonesContainer = document.getElementById('touch-zones');

        canvas.width = 800;
        canvas.height = 400;

        let gameState = 'START';
        let player = {};
        let platforms = [];
        let enemies = [];
        let clouds = [];
        let vines = [];
        let ziplines = [];
        let particles = [];
        let keys = {};
        let score = 0;
        let cameraX = 0;
        let lastGeneratedX = 0;
        let activeTouches = {}; 

        // --- KHOI TAO GAME ---
        function initGame() {
            score = 0; cameraX = 0; lastGeneratedX = 0;
            updateScoreUI();

            player = {
                x: 100, y: 200, width: 30, height: 45,
                velX: 0, velY: 0, speed: 5, jumpForce: 11,
                grounded: false, isDucking: false, canDoubleJump: true,
                isClimbing: false, isZipping: false,
                frameCount: 0, dir: -1
             };

            platforms = [{ x: 0, y: 350, width: 800, height: 50, type: 'ground' }];
            enemies = []; particles = []; vines = []; ziplines = []; 
            
            clouds = [];
            for(let i=0; i<6; i++) {
                clouds.push({ x: Math.random() * canvas.width, y: Math.random() * 150 + 20, speed: 0.2 + Math.random() * 0.3, size: 30 + Math.random() * 30 });
            }

            lastGeneratedX = 800;
            for(let i=0; i<8; i++) spawnNextChunk();
            
            keys = {};
            activeTouches = {}; 
        }

        function startGame() {
            initGame();
            gameState = 'PLAYING';
            startScreen.classList.remove('active');
            gameOverScreen.classList.remove('active');
            touchZonesContainer.style.display = 'grid';
        }

        function updateScoreUI() {
            scoreElement.innerText = "Distance: " + Math.floor(score) + "m";
        }

        // --- XU LY DIEU KHIEN ---
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        const handleTouch = (e) => {
            if (gameState !== 'PLAYING') return;
            e.preventDefault();

            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                const touchId = touch.identifier;

                if (e.type === 'touchstart' || e.type === 'touchmove') {
                    const newKey = target ? target.getAttribute('data-key') : null;
                    const oldKey = activeTouches[touchId];

                    if (newKey !== oldKey) {
                        if (oldKey) keys[oldKey] = false;
                        if (newKey) {
                            keys[newKey] = true;
                            activeTouches[touchId] = newKey;
                        } else {
                            delete activeTouches[touchId];
                        }
                    }
                } else if (e.type === 'touchend' || e.type === 'touchcancel') {
                    const keyToRelease = activeTouches[touchId];
                    if (keyToRelease) {
                        keys[keyToRelease] = false;
                        delete activeTouches[touchId];
                    }
                }
            }
        };

        touchZonesContainer.addEventListener('touchstart', handleTouch, { passive: false });
        touchZonesContainer.addEventListener('touchmove', handleTouch, { passive: false });
        touchZonesContainer.addEventListener('touchend', handleTouch, { passive: false });
        touchZonesContainer.addEventListener('touchcancel', handleTouch, { passive: false });

        function spawnNextChunk() {
            const rand = Math.random();
            let nextX = lastGeneratedX + 120 + Math.random() * 60;
            let nextY = 220 + Math.random() * 100;
            let width = 250 + Math.random() * 200;

            if (rand < 0.2) {
                const chainWidth = 350 + Math.random() * 150;
                platforms.push({ x: nextX, y: 300, width: 60, height: 30, type: 'platform' });
                platforms.push({ 
                     x: nextX + 60, y: 280, width: chainWidth, height: 20, 
                     type: 'chain_conveyor', bladeOffset: 0, 
                     bladeSpeed: 0.8 + Math.random() * 0.4 
                 });
                platforms.push({ x: nextX + 60 + chainWidth, y: 300, width: 120, height: 30, type: 'platform' });
                lastGeneratedX = nextX + chainWidth + 180;
            } else if (rand < 0.4) {
                const chasmWidth = 550;
                platforms.push({ x: nextX, y: 300, width: 80, height: 30, type: 'platform' });
                vines.push({ x: nextX + 60, y: 80, height: 220 });
                ziplines.push({ x1: nextX + 60, y1: 100, x2: nextX + 60 + chasmWidth, y2: 240 });
                platforms.push({ x: nextX + chasmWidth + 10, y: 300, width: 150, height: 30, type: 'platform' });
                lastGeneratedX = nextX + chasmWidth + 160;
            } else {
                platforms.push({ x: nextX, y: nextY, width: width, height: 30, type: 'platform' });
                
                // --- HAM GACH BAT BUOC CHUI ---
                if (Math.random() < 0.4 && width > 160) {
                    platforms.push({ 
                         x: nextX + width/2 - 40, 
                         y: nextY - 45, 
                         width: 80, 
                         height: 45, 
                         type: 'arch' 
                     });
                } else {
                    let eRand = Math.random();
                    if (eRand < 0.2) { enemies.push({ type: 'bird', x: nextX + width + 200, y: nextY - 80 - Math.random() * 60, width: 40, height: 30, speed: 1.5, dir: -1, hp: 1 }); }
                    else if (eRand < 0.45) { enemies.push({ type: 'worm', x: nextX + 30, y: nextY - 20, width: 40, height: 20, speed: 0.8, dir: 1, startX: nextX, endX: nextX + width, hp: 1 }); }
                    else if (eRand < 0.7) { enemies.push({ type: 'bug', x: nextX + 80, y: nextY - 40, width: 50, height: 40, speed: 1, dir: 1, startX: nextX, endX: nextX + width, hp: 2 }); }
                    else { enemies.push({ type: 'spikes', x: nextX + 110, y: nextY - 45, width: 40, height: 45 }); }
                }
                lastGeneratedX = nextX + width;
            }
        }

        function update() {
            if (gameState !== 'PLAYING') return;

            clouds.forEach(c => { c.x -= c.speed; if (c.x + c.size * 2 < 0) { c.x = canvas.width + 50; c.y = Math.random() * 150 + 20; } });

            let currentDist = (player.x - 100) / 20;
            if (currentDist > score) score = currentDist;
            updateScoreUI();

            let onVine = null;
            for (let v of vines) {
                if (player.x + player.width > v.x - 15 && player.x < v.x + 15 &&
                    player.y + player.height > v.y && player.y < v.y + v.height) {
                    onVine = v; break;
                }
            }
            if (onVine && (keys['ArrowUp'] || keys['ArrowDown'])) {
                player.isClimbing = true; player.isZipping = false; player.velY = 0;
                player.x = onVine.x - player.width/2;
            } else if (!onVine) { player.isClimbing = false; }

            if (!player.isZipping) {
                for (let z of ziplines) {
                    let d = Math.abs((z.y2 - z.y1) * player.x - (z.x2 - z.x1) * player.y + z.x2 * z.y1 - z.y2 * z.x1) / Math.sqrt(Math.pow(z.y2 - z.y1, 2) + Math.pow(z.x2 - z.x1, 2));
                    if (d < 30 && player.x > z.x1 && player.x < z.x2 && player.velY > -3) {
                        player.isZipping = true; player.isClimbing = false; player.grounded = false; break;
                    }
                }
            }

            if (player.isClimbing) {
                if (keys['ArrowUp']) player.y -= 3;
                if (keys['ArrowDown']) player.y += 3;
                if (keys['Space'] || keys['ArrowLeft'] || keys['ArrowRight']) {
                    player.isClimbing = false; if (keys['Space']) player.velY = -player.jumpForce;
                }
            } else if (player.isZipping) {
                player.velY = 0; player.x += 3; player.dir = 1;
                 let fz = false;
                for (let z of ziplines) {
                    if (player.x >= z.x1 && player.x <= z.x2) {
                        let t = (player.x - z.x1) / (z.x2 - z.x1);
                        player.y = z.y1 + t * (z.y2 - z.y1) + 20;
                         fz = true; break;
                    }
                }
                if (!fz) { player.isZipping = false; player.velY = 2; }
                if (keys['Space'] || keys['ArrowDown']) player.isZipping = false;
            } else {
                if (keys['ArrowLeft']) { player.velX = -player.speed; player.dir = -1; }
                else if (keys['ArrowRight']) { player.velX = player.speed; player.dir = 1; }
                else player.velX = 0;

                // --- XU LY NGOI ---
                if (keys['ArrowDown']) {
                    if (!player.isDucking) { player.isDucking = true; player.height = 25; player.y += 20; }
                } else {
                    if (player.isDucking) { player.isDucking = false; player.height = 45; player.y -= 20; }
                }

                if ((keys['ArrowUp'] || keys['KeyW'] || keys['Space']) && player.grounded) {
                    player.velY = -player.jumpForce; player.grounded = false; player.canDoubleJump = true;
                    keys['ArrowUp'] = keys['KeyW'] = keys['Space'] = false;
                } else if ((keys['ArrowUp'] || keys['KeyW'] || keys['Space']) && player.canDoubleJump) {
                    player.velY = -player.jumpForce * 0.8; player.canDoubleJump = false;
                    createParticles(player.x + player.width/2, player.y + player.height, '#fff', 5);
                    keys['ArrowUp'] = keys['KeyW'] = keys['Space'] = false;
                }
                player.velY += 0.5; player.x += player.velX; player.y += player.velY;
            }

            if (player.x < cameraX) player.x = cameraX;
            let targetCameraX = player.x - 250;
            if (targetCameraX > cameraX) cameraX = targetCameraX;

            if (!player.isClimbing && !player.isZipping) {
                player.grounded = false;
                for (let p of platforms) {
                    if (p.type === 'chain_conveyor') {
                        p.bladeOffset = (p.bladeOffset + p.bladeSpeed) % 200;
                        if (player.x < p.x + p.width && player.x + player.width > p.x && player.y + player.height >= p.y && player.y + player.height <= p.y + 20 && player.velY >= 0) {
                            player.y = p.y - player.height; player.velY = 0; player.grounded = true; player.canDoubleJump = true;
                            for (let i = -1; i < p.width / 100 + 1; i++) {
                                let bx = p.x + (i * 200) + p.bladeOffset;
                                if (bx > p.x && bx < p.x + p.width && Math.abs((player.x + player.width/2) - bx) < 25) endGame();
                            }
                        }
                    } else if (p.type === 'arch') {
                        if (player.x + player.width > p.x && player.x < p.x + p.width) {
                            if (!player.isDucking || player.y < p.y - 2) {
                                endGame();
                                showMessage("Ch·∫°m n√≥c h·∫ßm!");
                                return;
                            }
                        }
                    } else if (player.x < p.x + p.width && player.x + player.width > p.x && player.y < p.y + p.height && player.y + player.height > p.y) {
                        if (player.velY > 0 && player.y + player.height - player.velY <= p.y + 10) { player.y = p.y - player.height; player.velY = 0; player.grounded = true; player.canDoubleJump = true; }
                    }
                }
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];
                if (e.type !== 'spikes') {
                    if (e.type === 'worm') {
                        const wc = (player.frameCount * 0.1) % (Math.PI * 2);
                        if (wc < Math.PI) e.x += e.speed * e.dir * 1.5;
                    } else { e.x += (e.speed || 0) * (e.dir || 1); }
                    if (e.type === 'bird') { if (e.x < cameraX - 200 || e.x > cameraX + 1200) e.dir *= -1; }
                    else { if (e.x < e.startX || e.x + e.width > e.endX) e.dir *= -1; }
                }

                if (player.x < e.x + e.width && player.x + player.width > e.x && player.y < e.y + e.height && player.y + player.height > e.y) {
                    const playerFeet = player.y + player.height;
                    const enemyMiddle = e.y + e.height * 0.7;
                    
                     if (player.velY > 0 && playerFeet <= enemyMiddle + 15 && e.type !== 'spikes' && e.type !== 'bird') {
                        // Hieu ung tung bui khi giam quai
                        createParticles(e.x + e.width/2, e.y + e.height, '#8d6e63', 12); 
                        
                        if (e.type === 'bug' && e.hp > 1) {
                             e.hp--; player.velY = -player.jumpForce * 0.7; createParticles(e.x + 25, e.y, 'white', 5);
                         } else {
                             enemies.splice(i, 1); player.velY = -player.jumpForce * 0.7;
                         }
                    } else { endGame(); }
                }
            }

            if (player.x + canvas.width > lastGeneratedX) spawnNextChunk();
            if (player.y > canvas.height + 150) endGame();
            particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.alpha -= 0.02; if (p.alpha <= 0) particles.splice(i, 1); });
            player.frameCount++;
        }

        function endGame() {
             gameState = 'GAMEOVER';
             gameOverScreen.classList.add('active');
             finalScoreElement.innerText = "Qu√£ng ƒë∆∞·ªùng: " + Math.floor(score) + "m";
             touchZonesContainer.style.display = 'none';
        }

        function createParticles(x, y, color, count) { for (let i = 0; i < count; i++) { particles.push({ x, y, vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6, alpha: 1, color }); } }

        function drawEnemy(ctx, e, frameCount) {
            ctx.save();
            if (e.type === 'worm') {
                const wc = (frameCount * 0.1) % (Math.PI * 2);
                const ah = Math.max(0, Math.sin(wc) * 15);
                const bl = 40 - (ah * 0.5);
                ctx.fillStyle = '#7cfc00'; ctx.strokeStyle = '#32cd32'; ctx.lineWidth = 2;
                for(let i=0; i<5; i++) {
                    let dx = e.x + (i * bl / 4); let dy = e.y + 15;
                    if (i > 0 && i < 4) dy -= ah * (1 - Math.abs(2-i)*0.5);
                    ctx.beginPath(); ctx.arc(dx, dy, 6, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                    if ((e.dir > 0 && i === 4) || (e.dir < 0 && i === 0)) {
                        ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(dx + 2*e.dir, dy - 2, 2, 0, Math.PI * 2); ctx.fill();
                        ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(dx + 3*e.dir, dy - 2, 1, 0, Math.PI * 2); ctx.fill();
                    }
                }
            } else if (e.type === 'bug') {
                const mo = Math.abs(Math.sin(frameCount * 0.15)) * 0.7;
                ctx.fillStyle = '#9c27b0'; ctx.beginPath(); ctx.moveTo(e.x + 25, e.y + 20);
                let sa = (e.dir > 0) ? mo : Math.PI + mo;
                let ea = (e.dir > 0) ? Math.PI * 2 - mo : Math.PI - mo;
                ctx.arc(e.x + 25, e.y + 20, 20, sa, ea); ctx.closePath(); ctx.fill();
                ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(e.x + 25 + 5 * e.dir, e.y + 5, 7, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#6a1b9a'; ctx.beginPath(); ctx.arc(e.x + 25 + 7 * e.dir, e.y + 5, 3, 0, Math.PI * 2); ctx.fill();
                if (mo > 0.1) {
                    ctx.fillStyle = 'white';
                    for(let i=0; i<2; i++) {
                        let ta = (e.dir > 0) ? (i === 0 ? mo : -mo) : (i === 0 ? Math.PI - mo : Math.PI + mo);
                        let tx = e.x + 25 + Math.cos(ta) * 18; let ty = e.y + 20 + Math.sin(ta) * 18;
                        ctx.beginPath(); ctx.moveTo(tx, ty); ctx.lineTo(tx - 6 * e.dir, ty - 4); ctx.lineTo(tx - 6 * e.dir, ty + 4); ctx.fill();
                    }
                }
                if (e.hp > 1) { ctx.fillStyle = 'lime'; ctx.fillRect(e.x + 5, e.y - 15, 40, 4); }
            } else if (e.type === 'bird') {
                // CHINH CANH CHIM: Lat toan bo chim theo huong e.dir
                ctx.save();
                ctx.translate(e.x + 20, e.y + 15);
                ctx.scale(e.dir, 1); // Lat theo huong di chuyen
                
                // Than chim
                ctx.fillStyle = '#00bfff'; ctx.beginPath(); ctx.ellipse(0, 0, 18, 12, 0, 0, Math.PI * 2); ctx.fill();
                // Mat chim
                ctx.fillStyle = '#6a1b9a'; ctx.beginPath(); ctx.arc(12, -3, 2, 0, Math.PI * 2); ctx.fill();
                // Mo chim
                ctx.fillStyle = '#ff8c00'; ctx.beginPath(); ctx.moveTo(18, -3); ctx.lineTo(28, 0); ctx.lineTo(18, 3); ctx.fill();
                // Canh chim (flap)
                ctx.fillStyle = '#1e90ff'; 
                let wa = Math.sin(frameCount * 0.1) * 20; 
                ctx.beginPath(); 
                ctx.moveTo(0, 0); 
                ctx.lineTo(-25, -wa); 
                ctx.lineTo(-10, 10); 
                ctx.fill();
                
                ctx.restore();
            } else if (e.type === 'spikes') {
                ctx.fillStyle = '#2e7d32'; ctx.beginPath(); ctx.rect(e.x + 15, e.y + 5, 10, 40); ctx.fill();
                ctx.strokeStyle = '#2e7d32'; ctx.lineWidth = 6; ctx.lineCap = 'round';
                ctx.beginPath(); ctx.moveTo(e.x + 15, e.y + 25); ctx.lineTo(e.x + 5, e.y + 25); ctx.lineTo(e.x + 5, e.y + 15); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(e.x + 25, e.y + 15); ctx.lineTo(e.x + 35, e.y + 15); ctx.lineTo(e.x + 35, e.y + 5); ctx.stroke();
                ctx.fillStyle = '#1b5e20'; for(let k=0; k<5; k++) { ctx.fillRect(e.x + 18, e.y + 5 + k*8, 2, 2); }
            }
            ctx.restore();
        }

        function drawPlayer(ctx, p) {
            ctx.save(); ctx.translate(p.x + p.width/2, p.y + 12); ctx.scale(-p.dir, 1);
            let br = Math.sin(p.frameCount * 0.1) * 1.5;
            if (p.velX !== 0 || !p.grounded || p.isClimbing || p.isZipping) br = 0;
            const bodyH = p.isDucking ? 15 : 25;
            for(let side of [-1, 1]) {
                ctx.save(); let lx = side * 7; let ly = bodyH + 2;
                if (p.isZipping) { lx += Math.sin(p.frameCount * 0.1) * 8; ly -= 2; }
                else if (p.velX !== 0) { lx += Math.sin(p.frameCount * 0.2 + (side===1?0:Math.PI)) * 8; ly += Math.abs(Math.cos(p.frameCount * 0.2 + (side===1?0:Math.PI))) * 4; }
                ctx.fillStyle = '#111'; ctx.beginPath(); ctx.arc(lx, ly, 6, 0, Math.PI * 2); ctx.fill(); ctx.restore();
            }
            if (p.isZipping || p.isClimbing) {
                const hc = Math.sin(p.frameCount * 0.15); ctx.strokeStyle = '#3399ff'; ctx.lineWidth = 6; ctx.lineCap = 'round';
                for(let side of [-1, 1]) {
                    let hY = -25 + (side===1 ? (hc < 0 ? -hc * 15 : 0) : (hc > 0 ? hc * 15 : 0));
                    ctx.beginPath(); ctx.moveTo(side*5, 5); ctx.lineTo(side*12, hY); ctx.stroke();
                    ctx.fillStyle = '#ffdbac'; ctx.beginPath(); ctx.arc(side*12, hY, 5, 0, Math.PI * 2); ctx.fill();
                }
            } else {
                let aa = (p.velX !== 0 && p.grounded) ? Math.sin(p.frameCount * 0.2) * 0.6 : 0;
                ctx.save(); ctx.translate(0, 5);
                 ctx.save(); ctx.rotate(-aa); ctx.fillStyle = '#2288ee'; ctx.fillRect(-14, 0, 6, 18); ctx.restore();
                ctx.save(); ctx.rotate(aa); ctx.fillStyle = '#3399ff'; ctx.fillRect(8, 0, 6, 18); ctx.restore();
                ctx.restore();
            }
            ctx.fillStyle = '#3399ff'; ctx.fillRect(-10, br, 20, bodyH);
            ctx.translate(0, br); ctx.fillStyle = '#ffdbac'; ctx.beginPath(); ctx.arc(0, -2, 12, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#111'; ctx.beginPath(); ctx.arc(-4, -4, 2, 0, Math.PI * 2); ctx.arc(-8, -4, 2, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#ff4d4d'; ctx.beginPath(); ctx.arc(0, -7, 15, Math.PI, 0); ctx.fill(); ctx.fillRect(-15, -10, 30, 4);
            ctx.restore();
        }

        function drawBrickStructure(ctx, x, y, w, h) {
            ctx.save();
            ctx.fillStyle = '#b71c1c'; 
            ctx.fillRect(x, y, w, h);
            ctx.strokeStyle = '#ffffff'; 
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.4;
            const bW = 20; const bH = 10;
            for(let j = 0; j < h; j += bH) {
                ctx.beginPath();
                ctx.moveTo(x, y + j);
                ctx.lineTo(x + w, y + j);
                ctx.stroke();
                let offset = (j / bH) % 2 === 0 ? 0 : bW / 2;
                for(let i = offset; i < w; i += bW) {
                    ctx.beginPath();
                    ctx.moveTo(x + i, y + j);
                    ctx.lineTo(x + i, y + j + bH);
                    ctx.stroke();
                }
            }
            ctx.restore();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(700, 60, 25, 0, Math.PI * 2); ctx.fill();
            clouds.forEach(c => { ctx.fillStyle = 'white'; ctx.globalAlpha = 0.8; ctx.beginPath(); ctx.arc(c.x, c.y, c.size, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; });
            ctx.save(); ctx.translate(-cameraX, 0);
            
            vines.forEach(v => {
                ctx.save(); ctx.strokeStyle = '#228B22'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(v.x, v.y); ctx.lineTo(v.x, v.y + v.height); ctx.stroke();
                ctx.fillStyle = '#32CD32'; for(let i=0; i<v.height; i+=20) { ctx.beginPath(); ctx.arc(v.x + 5, v.y + i, 4, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(v.x - 5, v.y + i + 10, 4, 0, Math.PI * 2); ctx.fill(); }
                ctx.restore();
            });
            
            ziplines.forEach(z => {
                ctx.save(); ctx.strokeStyle = '#777'; ctx.lineWidth = 3; ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(z.x1, z.y1); ctx.lineTo(z.x2, z.y2); ctx.stroke();
                ctx.setLineDash([]); ctx.fillStyle = '#555'; ctx.fillRect(z.x1-5, z.y1-10, 10, 20); ctx.fillRect(z.x2-5, z.y2-10, 10, 20); ctx.restore();
            });

            platforms.forEach(p => {
                if (p.type === 'chain_conveyor') {
                    ctx.save(); ctx.strokeStyle = '#555'; ctx.lineWidth = 6; ctx.beginPath(); ctx.moveTo(p.x, p.y + 10); ctx.lineTo(p.x + p.width, p.y + 10); ctx.stroke();
                    ctx.fillStyle = '#777'; for(let x = p.x; x < p.x + p.width; x += 15) { ctx.beginPath(); ctx.arc(x, p.y + 10, 4, 0, Math.PI * 2); ctx.fill(); }
                    ctx.fillStyle = '#ff1744'; for (let i = -1; i < p.width / 100 + 1; i++) {
                        let bx = p.x + (i * 200) + p.bladeOffset; if (bx > p.x && bx < p.x + p.width) {
                            ctx.save(); ctx.translate(bx, p.y + 5); ctx.rotate(Date.now() / 100); ctx.beginPath();
                            for (let a = 0; a < 8; a++) { let ang = (a/8)*Math.PI*2; ctx.lineTo(Math.cos(ang)*15, Math.sin(ang)*15); ctx.lineTo(Math.cos(ang+0.2)*8, Math.sin(ang+0.2)*8); }
                            ctx.closePath(); ctx.fill(); ctx.strokeStyle = 'white'; ctx.lineWidth = 1; ctx.stroke(); ctx.restore();
                        }
                    } ctx.restore();
                } else if (p.type === 'arch') {
                    drawBrickStructure(ctx, p.x, p.y, 12, p.height);
                    drawBrickStructure(ctx, p.x + p.width - 12, p.y, 12, p.height);
                    drawBrickStructure(ctx, p.x, p.y - 15, p.width, 15);
                    
                    // --- KINH KONG THO TREN NOC ---
                    ctx.save();
                    const kX = p.x + p.width / 2;
                    const kY = p.y - 15;
                    const breathe = Math.sin(Date.now() / 400) * 2;
                    
                    ctx.fillStyle = '#3e2723';
                    // Dui
                    ctx.beginPath(); ctx.ellipse(kX - 25, kY - 4, 15, 6, 0, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(kX + 25, kY - 4, 15, 6, 0, 0, Math.PI * 2); ctx.fill();
                    // Than (Phinh ra khi tho)
                    ctx.beginPath(); ctx.ellipse(kX, kY - 35, 55 + breathe, 45 + breathe/2, 0, 0, Math.PI * 2); ctx.fill();
                    // Bung
                    ctx.fillStyle = '#5d4037';
                    ctx.beginPath(); ctx.ellipse(kX, kY - 30, 35 + breathe * 0.8, 28 + breathe * 0.5, 0, 0, Math.PI * 2); ctx.fill();
                    // Tay
                    ctx.fillStyle = '#3e2723';
                    ctx.beginPath(); ctx.ellipse(kX - 58 - breathe/2, kY - 25, 20, 35, 0.2, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(kX + 58 + breathe/2, kY - 25, 20, 35, -0.2, 0, Math.PI * 2); ctx.fill();
                    // Dau
                    ctx.beginPath(); ctx.ellipse(kX, kY - 78, 32, 26, 0, 0, Math.PI * 2); ctx.fill();
                    // Tai
                    ctx.beginPath(); ctx.arc(kX - 30, kY - 84, 9, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(kX + 30, kY - 84, 9, 0, Math.PI*2); ctx.fill();
                    // Mom
                    ctx.fillStyle = '#8d6e63';
                    ctx.beginPath(); ctx.ellipse(kX, kY - 74, 24, 16, 0, 0, Math.PI * 2); ctx.fill();
                    // Mat
                    ctx.fillStyle = 'white';
                    ctx.beginPath(); ctx.arc(kX - 10, kY - 86, 6, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(kX + 10, kY - 86, 6, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath(); ctx.arc(kX - 10, kY - 86, 3, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(kX + 10, kY - 86, 3, 0, Math.PI*2); ctx.fill();
                    // Lo mui
                    ctx.beginPath(); ctx.arc(kX - 4, kY - 72, 2, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(kX + 4, kY - 72, 2, 0, Math.PI*2); ctx.fill();
                    ctx.restore();
                } else { ctx.fillStyle = p.color || '#8d6e63'; ctx.fillRect(p.x, p.y, p.width, p.height); }
            });

            for (let e of enemies) drawEnemy(ctx, e, player.frameCount);
            particles.forEach(p => { ctx.globalAlpha = p.alpha; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI * 2); ctx.fill(); });
            ctx.globalAlpha = 1; drawPlayer(ctx, player);
            ctx.restore();
        }

        function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }
        window.onload = function() { initGame(); gameLoop(); };

        function showMessage(msg) {
             messageBox.innerText = msg;
             messageBox.style.display = 'block';
             setTimeout(() => messageBox.style.display = 'none', 1500);
         }
    </script>
</body>
</html>
